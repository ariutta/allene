#!/usr/bin/env bash

# see https://stackoverflow.com/a/246128/5354298
get_script_dir() { echo "$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"; }
SCRIPT_DIR=$(get_script_dir)
START_DIR=$(pwd)
on_error() {
  true
}
cleanup_complete=0
cleanup() {
  cd "$START_DIR" || return
  cleanup_complete=1
}
# Based on http://linuxcommand.org/lc3_wss0140.php
# and https://codeinthehole.com/tips/bash-error-reporting/
error_exit() {
  #	----------------------------------------------------------------
  #	Function for exit due to fatal program error
  #		Accepts 1 argument:
  #			string containing descriptive error message
  #	----------------------------------------------------------------

  on_error

  read -r line file <<<"$(caller)"
  if [ ! -e "$file" ]; then
    file="$SCRIPT_DIR/$file"
  fi
  echo "" 1>&2
  echo "ERROR: file $file, line $line" 1>&2
  if [ ! "$1" ] && [ -e "$file" ]; then
    sed "${line}q;d" "$file" 1>&2
  else
    echo "${1:-"Unknown Error"}" 1>&2
  fi
  echo "" 1>&2

  # TODO: should error_exit call cleanup?
  #       The EXIT trap already calls cleanup, so
  #       calling it here means calling it twice.
  if [ ! $cleanup_complete ]; then
    cleanup
  fi
  exit 1
}
trap error_exit ERR
trap cleanup EXIT INT QUIT TERM
shopt -s globstar
shopt -s extglob

if [ "$1" == "-h" ] || [ "$1" == "--help" ]; then
  echo "allene update"
  echo "Update all my enabled dependencies (excluding those in 'available')."
  exit 0
fi

if [ -z "$ALLENE_PACMAN_CLI" ]; then
  ALLENE_PACMAN_CLI="npm"
fi

get_pkg_info() {
  pkg="$1"
  #echo "pkg: $pkg" >/dev/stderr
  pkg_info='{}'
  if [ "$ALLENE_PACMAN_CLI" == "yarn" ]; then
    pkg_info=$(yarn info --json "$pkg" | jq -r '.data')
  else
    pkg_info=$(npm info --json "$pkg")
  fi
  echo "$pkg_info"
}

# TODO: Fix collect-dependencies to check whether top-level package.json exists,
# and, if so, only overwrite if my package's dependency is more newer.
# We don't want to pull up a bunch of outdated version numbers.
#ALLENE_PACMAN_CLI="$ALLENE_PACMAN_CLI" "$SCRIPT_DIR"/collect-dependencies

touch yarn.lock package-lock.json
rm yarn.lock package-lock.json
eval "$ALLENE_PACMAN_CLI install"
if [ "$ALLENE_PACMAN_CLI" == "yarn" ]; then
  #yarn upgrade
  # TODO: yarn upgrade doesn't update package.json
  # See issue https://github.com/yarnpkg/yarn/issues/3266

  # This will just upgrade package.json to the latest version, ignoring semver:
  #jq '.dependencies | keys | .[]' package.json | xargs yarn add

  # This allows the user to choose and at least sometimes updates package.json
  yarn upgrade-interactive
else
  npm update
fi

if [ "$ALLENE_PACMAN_CLI" == "yarn" ]; then
  yarn audit
  echo "Notice: there is no yarn equivalent to 'npm audit fix'. See https://github.com/yarnpkg/yarn/issues/7075" 1>&2
else
  npm audit fix
fi

package_json_paths=$(ls -1 packages/node_modules/!(available)/**/package.json)

names=$(jq -sr '.[] | .name' my-packages.json)

package_json_path="./package.json"
#lockfile_path="./package-lock.json"
#third_party_dependencies=$(jq '(.dependencies // {}) | to_entries | reduce .[] as $item ({}; .[$item.key] |= $item.value.version)' $lockfile_path)
third_party_dependencies=$(jq '(.dependencies // {})' $package_json_path)

#for pkg in $names; do
#	echo "resetting package.json for $pkg..."
#
#	child_dir="./packages/node_modules/$pkg"
#
#	cd "$child_dir" || error_exit "Error: 'cd \"$child_dir\"' failed."
#	if [ ! -f ./package.json ]; then
#	  cp ./package.json ./package-lkg.json
#	fi
#	git checkout package.json
#	cd "$START_DIR" || error_exit "Error: 'cd \"$START_DIR\"' failed."
#done

# alle_dependencies: all packages, both mine and third-party, for this project.
# Includes the version number of each package. For my packages, uses version
# number specified locally in packages/node_modules/<pkg>/package.json.
alle_dependencies=$(jq --slurp \
  --argjson third_party_dependencies "$third_party_dependencies" \
  'reduce .[] as $item ($third_party_dependencies; .[$item.name] |= $item.version)' \
  $package_json_paths)

QUERY=$(
  (sed 's/^\s*//g' | tr -d '\012') <<END
(.[\$dep_key] // {}) |
to_entries |
map({
  "key": .key,
  "value": (
    if (\$alle_dependencies[.key] != null) 
    then \$alle_dependencies[.key] 
    else .value 
    end
  )
}) |
from_entries
END
)

for pkg in $names; do
  cd "$START_DIR" || error_exit "Error: 'cd \"$START_DIR\"' failed."

  echo "**********************************"
  echo "* $pkg"
  echo "**********************************"

  echo "$pkg: updating package.json"

  has_dependencies=$(jq 'has("dependencies")' ./packages/node_modules/"$pkg"/package.json)
  has_dev_dependencies=$(jq 'has("devDependencies")' ./packages/node_modules/"$pkg"/package.json)

  child_package_json_path="./packages/node_modules/$pkg/package.json"
  child_package_json_tmp_path="./packages/node_modules/$pkg/package_tmp.json"
  updated_ds_path="./packages/node_modules/$pkg/updated_ds.json"

  latest_published_version=$(get_pkg_info "$pkg" | jq '.versions | last')
  package_json_version=$(jq '.version' "$child_package_json_path")
  if [ "$latest_published_version" != "$package_json_version" ]; then
    error_exit "Latest published version: $latest_published_version vs. package.json version: $package_json_version"
    # TODO: does this handle the case like cget/cxsd?
    #       cget has cxsd as a dev dep, but
    #       cxsd has cget as a dependency.
    #       We basically always just want to use the second-to-latest version of
    #       cxsd as the dev dependency for cget in this case.
  fi

  if [ "$has_dependencies" != 'true' ] && [ "$has_dev_dependencies" != 'true' ]; then
    echo "$pkg has no deps."
    continue
  fi

  if [ "$has_dependencies" == 'true' ]; then
    jq --arg dep_key 'dependencies' --argjson alle_dependencies "$alle_dependencies" \
      "$QUERY" \
      "$child_package_json_path" >"$updated_ds_path"

    jq --slurpfile updated_ds "$updated_ds_path" \
      '(.dependencies // {}) |= $updated_ds[0]' "$child_package_json_path" >"$child_package_json_tmp_path"

    mv "$child_package_json_tmp_path" "$child_package_json_path"
    rm "$updated_ds_path"
  fi

  if [ "$has_dev_dependencies" == 'true' ]; then
    jq --arg dep_key 'devDependencies' --argjson alle_dependencies "$alle_dependencies" \
      "$QUERY" \
      "$child_package_json_path" >"$updated_ds_path"

    jq --slurpfile updated_ds "$updated_ds_path" \
      '(.devDependencies // {}) |= $updated_ds[0]' "$child_package_json_path" >"$child_package_json_tmp_path"

    mv "$child_package_json_tmp_path" "$child_package_json_path"
    rm "$updated_ds_path"
  fi

  child_dir="./packages/node_modules/$pkg"

  cd "$child_dir" || error_exit "Error: 'cd \"$child_dir\"' failed."

  # TODO: instead of cd'ing into the child directory,
  # could/should we use npm explore? Example:
  #   npm explore kaavio -- npm run build

  #git status -s

  echo "$pkg: updating lockfile and building"
  touch yarn.lock package-lock.json
  rm yarn.lock package-lock.json
  if [ "$ALLENE_PACMAN_CLI" == "yarn" ]; then
    # NOTE: yarn generate-lock-entry isn't correct
    # See issue https://github.com/yarnpkg/yarn/issues/2340
    yarn install --modules-folder "$START_DIR"/node_modules
  else
    npm install --package-lock-only
    npm run --silent build || error_exit \
      "Error: 'npm run --silent build' failed for $pkg. Remove '--silent' to debug."
  fi
#  # Re-enable the following when yarn generate-lock-entry is fixed:
#  "$ALLENE_PACMAN_CLI" run --silent build || error_exit \
#    "Error: '$ALLENE_PACMAN_CLI run --silent build' failed for $pkg. Remove '--silent' to debug."

  echo "$pkg: testing"
  "$ALLENE_PACMAN_CLI" run --silent test || error_exit \
    "Error: '$ALLENE_PACMAN_CLI run --silent test' failed for $pkg. Remove '--silent' to debug."

  cd "$START_DIR" || error_exit "Error: 'cd \"$START_DIR\"' failed."
done

if ! "$ALLENE_PACMAN_CLI" audit; then
  if [ "$ALLENE_PACMAN_CLI" == "npm" ]; then
    echo 'You can try to force the fixes, but be ready to address breaking changes:'
    echo "  $ALLENE_PACMAN_CLI audit fix --force"
  fi
fi
"$ALLENE_PACMAN_CLI" outdated || echo "TODO: update dependencies manually."
