#!/usr/bin/env bash

# see https://stackoverflow.com/a/246128/5354298
get_script_dir() { echo "$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"; }
SCRIPT_DIR=$(get_script_dir)
START_DIR=$(pwd)
PKG_INFO_CACHE="$START_DIR"/.pkg_info_cache
###################
# Custom variables
###################
PEER_DEPENDENCIES_BY_DEPENDENT_F="$START_DIR"/peer-dependencies-by-dependent.json
PEER_DEPENDENTS_BY_DEPENDENCY_F="$START_DIR"/peer-dependents-by-dependency.json
on_error() {
  if [ -e "$PEER_DEPENDENCIES_BY_DEPENDENT_F" ]; then
    rm "$PEER_DEPENDENCIES_BY_DEPENDENT_F"
  fi
}
cleanup_complete=0
cleanup() {
  cd "$START_DIR" || return
  if [ -e "$PEER_DEPENDENTS_BY_DEPENDENCY_F" ]; then
    rm "$PEER_DEPENDENTS_BY_DEPENDENCY_F"
  fi
  if [ -d "$PKG_INFO_CACHE" ]; then
    rm -rf "$PKG_INFO_CACHE"
  fi
  cleanup_complete=1
}
# Based on http://linuxcommand.org/lc3_wss0140.php
# and https://codeinthehole.com/tips/bash-error-reporting/
error_exit() {
  #	----------------------------------------------------------------
  #	Function for exit due to fatal program error
  #		Accepts 1 argument:
  #			string containing descriptive error message
  #	----------------------------------------------------------------

  on_error

  read -r line file <<<"$(caller)"
  if [ ! -e "$file" ]; then
    file="$SCRIPT_DIR/$file"
  fi
  echo "" 1>&2
  echo "ERROR: file $file, line $line" 1>&2
  if [ ! "$1" ] && [ -e "$file" ]; then
    sed "${line}q;d" "$file" 1>&2
  else
    echo "${1:-"Unknown Error"}" 1>&2
  fi
  echo "" 1>&2

  # TODO: should error_exit call cleanup?
  #       The EXIT trap already calls cleanup, so
  #       calling it here means calling it twice.
  if [ ! $cleanup_complete ]; then
    cleanup
  fi
  exit 1
}
trap error_exit ERR
trap cleanup EXIT INT QUIT TERM
shopt -s globstar
shopt -s extglob

if [ "$1" == "-h" ] || [ "$1" == "--help" ]; then
  echo "allene init <pkg>"
  echo "Create an alle structure for the specified package"
  exit 0
fi

# shellcheck source=utils.sh
. "$SCRIPT_DIR"/utils.sh || error_exit "Failed to source utils.sh"
[ -z "$ALLENE_PACMAN_CLI" ] && error_exit "ALLENE_PACMAN_CLI not set"

pkg_in="$1"
username=""
if [ "$ALLENE_PACMAN_CLI" == "yarn" ]; then
  username=$(yarn login --json | jq -r '.data | capture("npm\\ username:\\ (?<username>.+)") | .username')
else
  username=$(npm whoami)
fi

[ -z "$username" ] && error_exit "Please log in: $ALLENE_PACMAN_CLI login"

if [ ! -e ./package.json ]; then
  cat >package.json <<END
{
  "name": "$pkg_in-alle",
  "private": true,
  "version": "0.0.0",
  "dependencies": {}
}
END
fi

echo "creating my-packages.json..." 1>&2
if [ ! -e ./my-packages.json ]; then
  echo "processing $pkg_in for my-packages.json..." 1>&2
  repo_url=$(get_pkg_info "$pkg_in" |
    jq -r '.repository.url |
    capture("\\.com\\/(?<user>([\\w\\-]+))\\/(?<repo>([\\w\\-]+))") |
    "git@github.com:\(.user)/\(.repo).git"'
  )
  echo "{\"name\": \"$pkg_in\", \"repository\": \"$repo_url\"}" >> ./my-packages.json
  echo "detecting $pkg_in deps developed/maintained by $username..." 1>&2
  for dep in $(get_my_deps "$username" "$pkg_in"); do
    echo "processing $dep for my-packages.json..." 1>&2
    repo_url=$(get_pkg_info "$dep" |
      jq -r '.repository.url |
      capture("\\.com\\/(?<user>([\\w\\-]+))\\/(?<repo>([\\w\\-]+))") |
      "git@github.com:\(.user)/\(.repo).git"'
    )
    echo "{\"name\": \"$dep\", \"repository\": \"$repo_url\"}" |
      cat - ./my-packages.json > temp &&
      mv temp ./my-packages.json
  done
fi

if [ -e ./my-packages.json ] && [ ! -d packages/node_modules ]; then
  echo "making directories for my packages..." 1>&2
  jq -sr '.[] | "mkdir -p ./packages/node_modules/\(.name)" | @sh' "./my-packages.json" | \
    xargs -n 1 -P 4 -i{} sh -c "{}"
#  jq -sr '.[] | "mkdir -p ./packages/node_modules/\(.name)"' "./my-packages.json" |
#    while read -r cmd; do
#      $cmd
#    done

  echo "cloning my packages..." 1>&2
  jq -sr '.[] | "git clone \(.repository) ./packages/node_modules/\(.name)" | @sh' "./my-packages.json" | \
    xargs -n 1 -P 4 -i{} sh -c "{}"
#  jq -sr '.[] | "git clone \(.repository) ./packages/node_modules/\(.name)"' "./my-packages.json" |
#    while read -r cmd; do
#      $cmd
#    done
fi

echo "collecting dependencies..." 1>&2
ALLENE_PACMAN_CLI="$ALLENE_PACMAN_CLI" "$SCRIPT_DIR"/collect-dependencies

echo "Detecting peer dependencies (background task)" 1>&2
(detect_peer_dependencies &)

echo "installing..." 1>&2
eval "$ALLENE_PACMAN_CLI install"
echo "linking bins..." 1>&2
ALLENE_PACMAN_CLI="$ALLENE_PACMAN_CLI" "$SCRIPT_DIR"/link-bins
echo "building..." 1>&2

if [ ! -e pkg_batches.json ]; then
  echo "detecting package batches..." 1>&2
  jq -s 'map(.name) | .[]' $(get_pkg_json_paths) >my_pkgs.json
  if [ "$ALLENE_PACMAN_CLI" == "yarn" ]; then
    echo "TODO: get reqs_by_dep via yarn" 1>&2
    npm install --package-lock-only
  fi
  reqs_by_dep=$(jq --slurpfile my_pkgs my_pkgs.json \
    'walk(
      if type == "object" then
        (
          to_entries |
          map(select(
            ([.key] - ($my_pkgs + ["dependencies", "requires"])) | first | not
          )) |
          from_entries
        )
      else
        .
      end
    ) |
    .dependencies |
    to_entries |
    map({
      (.key): (
        if (.value | has("requires")) then
          (.value.requires | keys)
        else
          []
        end
      )
    })' \
    package-lock.json)

  if [ "$ALLENE_PACMAN_CLI" == "yarn" ]; then
    rm package-lock.json
  fi

  rm my_pkgs.json

  get_pkg_batches "$reqs_by_dep" > pkg_batches.json
fi

echo "building packages..." 1>&2
for pkg_f in $(get_pkg_json_paths); do
  dir_path=$(dirname "$pkg_f")
  echo "$dir_path" 1>&2
  mkdir -p "$(dirname "./tmp/$dir_path")"
  mv "$dir_path" ./tmp/"$dir_path"
done

for batch in $(jq -r 'map(join("|")) | .[]' pkg_batches.json); do
  echo "$batch" | \
    jq -Rr 'split("|") | map("\(.)\n") | .[]' | \
    # TODO: how should -P be set? The machine won't necessarily have 4 cores/processors
    xargs -n 1 -P 4 -i{} sh -c "echo \"building {}\" 1>&2; mv \"tmp/packages/node_modules/{}\" \"packages/node_modules/{}\" && cd \"packages/node_modules/{}\" && \"$ALLENE_PACMAN_CLI\" run build && cd \"$START_DIR\"" ||
	error_exit "Failed to build"
done
rm -rf ./tmp
for batch in $(jq -r 'map(join("|")) | .[]' pkg_batches.json); do
  echo "$batch" | \
    jq -Rr 'split("|") | map("\(.)\n") | .[]' | \
    xargs -n 1 -P 4 -i{} sh -c "echo \"rebuilding {}\" 1>&2; cd \"packages/node_modules/{}\" && \"$ALLENE_PACMAN_CLI\" run build && cd \"$START_DIR\"" ||
	error_exit "Failed to rebuild"
done
