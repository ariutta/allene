#!/usr/bin/env bash

# see https://stackoverflow.com/a/246128/5354298
get_script_dir() { echo "$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"; }
SCRIPT_DIR=$(get_script_dir)
START_DIR=$(pwd)
###################
# Custom variables
###################
PEER_DEPENDENCIES_BY_DEPENDENT_F="$START_DIR"/peer-dependencies-by-dependent.json
PEER_DEPENDENTS_BY_DEPENDENCY_F="$START_DIR"/peer-dependents-by-dependency.json
if [ "$ALLENE_PACMAN_CLI" == "yarn" ]; then
  username=$(yarn login --json | jq -r '.data | capture("npm\\ username:\\ (?<username>.+)") | .username')
else
  username=$(npm whoami)
fi
on_error() {
  if [ -e "$PEER_DEPENDENCIES_BY_DEPENDENT_F" ]; then
    rm "$PEER_DEPENDENCIES_BY_DEPENDENT_F"
  fi
}
cleanup_complete=0
cleanup() {
  echo 'Cleaning up...'
  cd "$START_DIR" || return
  if [ -e "$PEER_DEPENDENTS_BY_DEPENDENCY_F" ]; then
    rm "$PEER_DEPENDENTS_BY_DEPENDENCY_F"
  fi
  cleanup_complete=1
}
# Based on http://linuxcommand.org/lc3_wss0140.php
# and https://codeinthehole.com/tips/bash-error-reporting/
error_exit() {
  #	----------------------------------------------------------------
  #	Function for exit due to fatal program error
  #		Accepts 1 argument:
  #			string containing descriptive error message
  #	----------------------------------------------------------------

  on_error

  read -r line file <<<"$(caller)"
  if [ ! -e "$file" ]; then
    file="$SCRIPT_DIR/$file"
  fi
  echo "" 1>&2
  echo "ERROR: file $file, line $line" 1>&2
  if [ ! "$1" ] && [ -e "$file" ]; then
    sed "${line}q;d" "$file" 1>&2
  else
    echo "${1:-"Unknown Error"}" 1>&2
  fi
  echo "" 1>&2

  # TODO: should error_exit call cleanup?
  #       The EXIT trap already calls cleanup, so
  #       calling it here means calling it twice.
  if [ ! $cleanup_complete ]; then
    cleanup
  fi
  exit 1
}
trap error_exit ERR
trap cleanup EXIT INT QUIT TERM
shopt -s globstar
shopt -s extglob

if [ -z "$ALLENE_PACMAN_CLI" ]; then
  if yarn --version > /dev/null 2>&1; then
    ALLENE_PACMAN_CLI="yarn"
  else
    ALLENE_PACMAN_CLI="npm"
  fi
  echo "Using $ALLENE_PACMAN_CLI"
  export ALLENE_PACMAN_CLI="$ALLENE_PACMAN_CLI"
fi

if [ "$1" == "-h" ] || [ "$1" == "--help" ]; then
  echo "allene commands:"
  for f in "$SCRIPT_DIR"/src/*; do
    if [ -x "$f" ]; then
      basename "$f"
    fi
  done
  exit 0
fi

# from https://stackoverflow.com/a/8574392
contains_element () {
  local e match="$1"
  shift
  for e; do [[ "$e" == "$match" ]] && return 0; done
  return 1
}

get_pkg_info() {
  pkg="$1"
  #echo "pkg: $pkg" >/dev/stderr
  pkg_info='{}'
  if [ "$ALLENE_PACMAN_CLI" == "yarn" ]; then
    pkg_info=$(yarn info --json "$pkg" | jq -r '.data')
  else
    pkg_info=$(npm info --json "$pkg")
  fi
  echo "$pkg_info"
}

get_deps() {
  pkg="$1"
  for dep in $(get_pkg_info "$pkg" | jq -r '(.dependencies // {}) + (.devDependencies // {}) + (.peerDependencies // {}) | keys | .[]'); do
    echo "$dep"
  done
}

get_my_deps() {
  username="$1"
  pkg="$2"
  collected="$3"
  if [[ -z "$collected" ]]; then
    collected=("$pkg")
  fi
  for dep in $(get_deps "$pkg"); do
    maintainers=''
    if [ "$ALLENE_PACMAN_CLI" == "yarn" ]; then
      maintainers=$(yarn info --json "$dep" | jq -r '.data.maintainers[].name')
    else
      maintainers=$(npm info --json "$dep" | jq -r '.maintainers[] | capture("^(?<name>([\\w\\-]+))\\ <(?<email>(.*))>") | .name')
    fi
    if echo "$maintainers" | rg -q "^$username\$"; then
      if ! contains_element "$dep" "${collected[@]}"; then
        echo "$dep"
        collected+=( "$dep" )
        get_my_deps "$username" "$dep" "${collected[@]}"
      fi
    fi
  done
}

pkg_in="$1"
username="$(whoami)"

if ! jq --version >/dev/null 2>&1; then
  error_exit "Install jq"
fi

if [[ -z "$username" ]]; then
  error_exit "Please log in: $ALLENE_PACMAN_CLI login"
fi

if [ ! -e ./local-packages.json ]; then
  repo_url=$(get_pkg_info "$pkg_in" | jq -r '.repository.url | capture("\\.com\\/(?<user>([\\w\\-]+))\\/(?<repo>([\\w\\-]+))") | "git@github.com:\(.user)/\(.repo).git"')
  echo "{\"name\": \"$pkg_in\", \"repository\": \"$repo_url\"}" >> ./local-packages.json
  for dep in $(get_my_deps "$username" "$pkg_in"); do
    repo_url=$(get_pkg_info "$dep" | jq -r '.repository.url | capture("\\.com\\/(?<user>([\\w\\-]+))\\/(?<repo>([\\w\\-]+))") | "git@github.com:\(.user)/\(.repo).git"')
    echo "{\"name\": \"$dep\", \"repository\": \"$repo_url\"}" | cat - ./local-packages.json > temp && mv temp ./local-packages.json
  done
fi

if [ -e ./local-packages.json ] && [ ! -d packages/node_modules ]; then
  # Make directories for the local packages
  jq -sr '.[] | "mkdir -p ./packages/node_modules/\(.name)"' "./local-packages.json" |
    while read -r cmd; do
      $cmd
    done

  # Clone the local packages
  jq -sr '.[] | "git clone \(.repository) ./packages/node_modules/\(.name)"' "./local-packages.json" |
    while read -r cmd; do
      $cmd
    done
fi

echo "collecting dependencies..."
"$SCRIPT_DIR"/collect-dependencies

detect_peer_dependencies() {
  if [ -e "$PEER_DEPENDENCIES_BY_DEPENDENT_F" ]; then
    rm "$PEER_DEPENDENCIES_BY_DEPENDENT_F"
  fi
  if [ -e "$PEER_DEPENDENTS_BY_DEPENDENCY_F" ]; then
    rm "$PEER_DEPENDENTS_BY_DEPENDENCY_F"
  fi
  echo "Detecting peer dependencies." >/dev/stderr

  for caret_versioned_pkg in $(jq -r '.dependencies | to_entries | map("\(.key)@\(.value)") | .[]' package.json); do
    pkg=${caret_versioned_pkg//\^/''}
    get_pkg_info "$pkg" | jq 'select(.peerDependencies) | {(.name): .peerDependencies | keys}' \
      >>"$PEER_DEPENDENTS_BY_DEPENDENCY_F" || break;
  done

  jq -s 'reduce .[] as $item({}; . * $item) | to_entries | map(select(.value | length > 0)) | map(.key as $mykey | reduce .value[] as $myvalue ({}; . * {($myvalue): [$mykey]})) | map(to_entries) | reduce .[] as $item ([]; . + $item) | reduce .[] as $item ({}; .[$item["key"]] += $item["value"])' \
    "$PEER_DEPENDENTS_BY_DEPENDENCY_F" > "$PEER_DEPENDENCIES_BY_DEPENDENT_F"
  rm "$PEER_DEPENDENTS_BY_DEPENDENCY_F"
}
#detect_peer_dependencies
(detect_peer_dependencies &)
#nohup detect_peer_dependencies &

echo "installing..."
eval "$ALLENE_PACMAN_CLI install"
echo "linking bins..."
"$SCRIPT_DIR"/link-bins
echo "building..."

package_json_paths=$(ls -1 packages/node_modules/!(available)/**/package.json)

for pkg_f in $package_json_paths; do
  dir_path=$(dirname "$pkg_f")
  echo "$dir_path"
  mkdir -p "$(dirname "./tmp/$dir_path")"
  mv "$dir_path" ./tmp/"$dir_path"
done

build_packages() {
  echo "building packages..."
  cd "$START_DIR" || error_exit "Cannot cd to $START_DIR"
  remaining_package_json_paths=$(ls -1 tmp/packages/node_modules/!(available)/**/package.json)
  if [ -z "$remaining_package_json_paths" ]; then
    return
  fi
  for pkg_f in $package_json_paths; do
    if [ ! -e "./tmp/$pkg_f" ]; then
      continue
    fi
    remaining_package_json_paths=$(ls -1 tmp/packages/node_modules/!(available)/**/package.json)
    local_dependencies=$(comm -12  <(jq -r '(.dependencies // {}) + (.peerDependencies // {}) | keys | .[]' "./tmp/$pkg_f" | sort -u) <(jq -r '.name' $remaining_package_json_paths | sort -u))
    if [ -n "$local_dependencies" ]; then
      continue
    fi
    dir_path=$(dirname "$pkg_f")
    mv "./tmp/$dir_path" "$dir_path"
    cd "$dir_path" || error_exit "Cannot cd to $dir_path"
    jq -r '.name' package.json >> "$START_DIR"/mydeps.tsv
    pwd
    eval "$ALLENE_PACMAN_CLI run build"
    cd "$START_DIR" || error_exit "Cannot cd to $START_DIR"
  done
  build_packages
}

touch "$START_DIR"/mydeps.tsv
rm "$START_DIR"/mydeps.tsv
build_packages
rm -rf ./tmp
"$SCRIPT_DIR"/each "$ALLENE_PACMAN_CLI run build"
