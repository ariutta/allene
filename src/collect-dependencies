#!/usr/bin/env bash

ALLE_PKG_JSON_PATH="./package.json"
ALLE_PKG_JSON_LKG_PATH="/tmp/package.lkg.json"
ALLE_PKG_JSON_UPDATED_PATH="/tmp/package.updated.json"

# see https://stackoverflow.com/a/246128/5354298
get_script_dir() { echo "$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"; }
SCRIPT_DIR=$(get_script_dir)
START_DIR=$(pwd)
on_error() {
  # Restoring last-know-good package.json
  cp "$ALLE_PKG_JSON_LKG_PATH" "$ALLE_PKG_JSON_PATH"
}
cleanup_complete=0
cleanup() {
  cd "$START_DIR" || return
  cleanup_complete=1
}
# Based on http://linuxcommand.org/lc3_wss0140.php
# and https://codeinthehole.com/tips/bash-error-reporting/
error_exit() {
  #	----------------------------------------------------------------
  #	Function for exit due to fatal program error
  #		Accepts 1 argument:
  #			string containing descriptive error message
  #	----------------------------------------------------------------

  on_error

  read -r line file <<<"$(caller)"
  if [ ! -e "$file" ]; then
    file="$SCRIPT_DIR/$file"
  fi
  echo "" 1>&2
  echo "ERROR: file $file, line $line" 1>&2
  if [ ! "$1" ] && [ -e "$file" ]; then
    sed "${line}q;d" "$file" 1>&2
  else
    echo "${1:-"Unknown Error"}" 1>&2
  fi
  echo "" 1>&2

  # TODO: should error_exit call cleanup?
  #       The EXIT trap already calls cleanup, so
  #       calling it here means calling it twice.
  if [ ! $cleanup_complete ]; then
    cleanup
  fi
  exit 1
}
trap error_exit ERR
trap cleanup EXIT INT QUIT TERM
shopt -s globstar
shopt -s extglob

if [ -z "$ALLENE_PACMAN_CLI" ]; then
  ALLENE_PACMAN_CLI="npm"
fi

if [ ! -e "$ALLE_PKG_JSON_PATH" ]; then
  error_exit "Missing alle top-level package.json"
fi

cp "$ALLE_PKG_JSON_PATH" "$ALLE_PKG_JSON_LKG_PATH"

package_json_paths=$(ls -1 packages/node_modules/!(available)/**/package.json)

names=$(jq -s 'map(.name)' $package_json_paths)

echo "Local packages found:"
echo "$names" | jq -r '.[]'

QUERY=$(
  (sed 's/^\s*//g' | tr -d '\012') <<END
map((.dependencies // {} | to_entries) + (.devDependencies // {} | to_entries)) |
flatten | group_by(.key) |
map(reduce .[] as \$item ({key: "", semvers: []}; {
  key: \$item["key"],
  semvers: (.semvers + [
    \$item["value"] |
    capture("(
      (?<alias>(npm:@?[\\\\w][\\\\w\\\\-\\\\/\\\\.]*)@?)?
      (
        ((?<prefix>[~^]?)?(?<major>[0-9]+).(?<minor>[0-9]+).(?<patch>[0-9]+))
        |
        (?<url>((git|http).*))
      )?
    )")
  ])
})) |
map({
  key,
  latest_semver: (.semvers | sort_by(.url, .major, .minor, .patch) | last)
}) |
map({
  (.key): (
    [
      .latest_semver.alias,
      .latest_semver.prefix,
      (
        .latest_semver |
        (
          [.url, .major, .minor, .patch] |
          map(select(. != null)) |
          map(tostring) |
          join(".")
        )
      )
    ] |
    map(select(. != null)) |
    join("")
  )
}) |
reduce .[] as \$item ({}; \$item * .) | . as \$mergedDependencies |
keys |
reduce .[] as \$includeName ({}; {(\$includeName): \$mergedDependencies[\$includeName]} * .) | . as \$collectedDependencies
| \$packageJson | .dependencies |= \$collectedDependencies
END
)

#keys - \$excludeNames |

# Collect the latest versions of each dependency that is
# not under development in this alle project and apply
# the results to update the top-level alle package.json.
# In the capture section, we are extracting urls and semvers,
# but we are not currently handling git references.
jq -s --sort-keys --argjson excludeNames "$names" --argfile packageJson "$ALLE_PKG_JSON_PATH" \
  "$QUERY" \
  $package_json_paths >"$ALLE_PKG_JSON_UPDATED_PATH"
mv "$ALLE_PKG_JSON_UPDATED_PATH" "$ALLE_PKG_JSON_PATH"
